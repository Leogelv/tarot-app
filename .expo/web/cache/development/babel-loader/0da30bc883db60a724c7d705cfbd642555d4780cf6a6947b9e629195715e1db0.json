{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport React, { useRef, useState, useEffect } from 'react';\nimport View from \"react-native-web/dist/exports/View\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport Dimensions from \"react-native-web/dist/exports/Dimensions\";\nimport { Canvas, useFrame, useLoader } from '@react-three/fiber/native';\nimport { TextureLoader } from 'three';\nimport { useGLTF } from '@react-three/drei/native';\nimport { PanGestureHandler, RotationGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { useAnimatedGestureHandler, useSharedValue, useAnimatedStyle, withSpring, withTiming, runOnJS } from 'react-native-reanimated';\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nvar _Dimensions$get = Dimensions.get('window'),\n  width = _Dimensions$get.width,\n  height = _Dimensions$get.height;\nvar CardModel = function CardModel(_ref) {\n  var cardImage = _ref.cardImage,\n    backImage = _ref.backImage,\n    isFlipped = _ref.isFlipped,\n    rotateX = _ref.rotateX,\n    rotateY = _ref.rotateY,\n    onFlipComplete = _ref.onFlipComplete;\n  var meshRef = useRef();\n  var targetRotationY = useSharedValue(isFlipped ? Math.PI : 0);\n  var currentRotationY = useSharedValue(isFlipped ? Math.PI : 0);\n  var _useState = useState(false),\n    _useState2 = _slicedToArray(_useState, 2),\n    flipping = _useState2[0],\n    setFlipping = _useState2[1];\n  var frontTexture = useLoader(TextureLoader, cardImage);\n  var backTexture = useLoader(TextureLoader, backImage);\n  useEffect(function () {\n    if (isFlipped !== currentRotationY.value > Math.PI / 2) {\n      setFlipping(true);\n      targetRotationY.value = isFlipped ? Math.PI : 0;\n    }\n  }, [isFlipped]);\n  useFrame(function (state, delta) {\n    if (meshRef.current) {\n      meshRef.current.rotation.x = rotateX.value;\n      if (flipping) {\n        var step = delta * 3;\n        var target = targetRotationY.value;\n        var current = currentRotationY.value;\n        if (Math.abs(current - target) < 0.01) {\n          currentRotationY.value = target;\n          setFlipping(false);\n          if (onFlipComplete) {\n            onFlipComplete();\n          }\n        } else {\n          currentRotationY.value += (target - current) * step;\n        }\n      }\n      meshRef.current.rotation.y = rotateY.value + currentRotationY.value;\n      meshRef.current.position.y = Math.sin(state.clock.elapsedTime) * 0.05;\n    }\n  });\n  return _jsxs(\"mesh\", {\n    ref: meshRef,\n    scale: [1.5, 2.25, 0.05],\n    children: [_jsx(\"boxGeometry\", {\n      args: [1, 1, 0.05]\n    }), _jsx(\"meshStandardMaterial\", {\n      map: frontTexture,\n      attachArray: \"material\"\n    }), _jsx(\"meshStandardMaterial\", {\n      map: frontTexture,\n      attachArray: \"material\"\n    }), _jsx(\"meshStandardMaterial\", {\n      map: backTexture,\n      attachArray: \"material\"\n    }), _jsx(\"meshStandardMaterial\", {\n      map: backTexture,\n      attachArray: \"material\"\n    }), _jsx(\"meshStandardMaterial\", {\n      map: frontTexture,\n      attachArray: \"material\"\n    }), _jsx(\"meshStandardMaterial\", {\n      map: backTexture,\n      attachArray: \"material\"\n    })]\n  });\n};\nvar TarotCard3D = function TarotCard3D(_ref2) {\n  var card = _ref2.card,\n    onFlip = _ref2.onFlip,\n    _ref2$initiallyFlippe = _ref2.initiallyFlipped,\n    initiallyFlipped = _ref2$initiallyFlippe === void 0 ? false : _ref2$initiallyFlippe,\n    style = _ref2.style;\n  var _useState3 = useState(initiallyFlipped),\n    _useState4 = _slicedToArray(_useState3, 2),\n    isFlipped = _useState4[0],\n    setIsFlipped = _useState4[1];\n  var rotateX = useSharedValue(0);\n  var rotateY = useSharedValue(0);\n  var cardImagePath = card != null && card.image ? require(\"../assets/images/tarot/m00.jpg\") : require(\"../assets/images/tarot/back.jpg\");\n  var backImagePath = require(\"../assets/images/tarot/back.jpg\");\n  var panGestureHandler = useAnimatedGestureHandler({\n    onStart: function onStart(_, ctx) {\n      ctx.startX = rotateY.value;\n      ctx.startY = rotateX.value;\n    },\n    onActive: function onActive(event, ctx) {\n      rotateY.value = ctx.startX + event.translationX / 100;\n      rotateX.value = ctx.startY - event.translationY / 100;\n    },\n    onEnd: function onEnd() {\n      rotateY.value = withSpring(0);\n      rotateX.value = withSpring(0);\n    }\n  });\n  var handleTap = function handleTap() {\n    setIsFlipped(!isFlipped);\n    if (onFlip) {\n      onFlip(!isFlipped);\n    }\n  };\n  var handleFlipComplete = function handleFlipComplete() {};\n  return _jsx(View, {\n    style: [styles.container, style],\n    children: _jsx(PanGestureHandler, {\n      onGestureEvent: panGestureHandler,\n      children: _jsx(Animated.View, {\n        style: styles.canvas,\n        children: _jsxs(Canvas, {\n          style: styles.canvas,\n          onTouchEnd: handleTap,\n          children: [_jsx(\"ambientLight\", {\n            intensity: 0.6\n          }), _jsx(\"pointLight\", {\n            position: [10, 10, 10],\n            intensity: 0.8\n          }), _jsx(CardModel, {\n            cardImage: cardImagePath,\n            backImage: backImagePath,\n            isFlipped: isFlipped,\n            rotateX: rotateX,\n            rotateY: rotateY,\n            onFlipComplete: handleFlipComplete\n          })]\n        })\n      })\n    })\n  });\n};\nvar styles = StyleSheet.create({\n  container: {\n    width: width * 0.8,\n    height: width * 1.2,\n    alignItems: 'center',\n    justifyContent: 'center'\n  },\n  canvas: {\n    width: '100%',\n    height: '100%',\n    borderRadius: 10,\n    overflow: 'hidden'\n  }\n});\nexport default TarotCard3D;","map":{"version":3,"names":["React","useRef","useState","useEffect","View","StyleSheet","Dimensions","Canvas","useFrame","useLoader","TextureLoader","useGLTF","PanGestureHandler","RotationGestureHandler","State","Animated","useAnimatedGestureHandler","useSharedValue","useAnimatedStyle","withSpring","withTiming","runOnJS","jsx","_jsx","jsxs","_jsxs","_Dimensions$get","get","width","height","CardModel","_ref","cardImage","backImage","isFlipped","rotateX","rotateY","onFlipComplete","meshRef","targetRotationY","Math","PI","currentRotationY","_useState","_useState2","_slicedToArray","flipping","setFlipping","frontTexture","backTexture","value","state","delta","current","rotation","x","step","target","abs","y","position","sin","clock","elapsedTime","ref","scale","children","args","map","attachArray","TarotCard3D","_ref2","card","onFlip","_ref2$initiallyFlippe","initiallyFlipped","style","_useState3","_useState4","setIsFlipped","cardImagePath","image","require","backImagePath","panGestureHandler","onStart","_","ctx","startX","startY","onActive","event","translationX","translationY","onEnd","handleTap","handleFlipComplete","styles","container","onGestureEvent","canvas","onTouchEnd","intensity","create","alignItems","justifyContent","borderRadius","overflow"],"sources":["/Users/gelvihleonid/Documents/AiDEV/CODEPROJECTS/TarotApp/src/components/3d/TarotCard3D.js"],"sourcesContent":["import React, { useRef, useState, useEffect } from 'react';\nimport { View, StyleSheet, Dimensions } from 'react-native';\nimport { Canvas, useFrame, useLoader } from '@react-three/fiber/native';\nimport { TextureLoader } from 'three';\nimport { useGLTF } from '@react-three/drei/native';\nimport { PanGestureHandler, RotationGestureHandler, State } from 'react-native-gesture-handler';\nimport Animated, { \n  useAnimatedGestureHandler, \n  useSharedValue, \n  useAnimatedStyle, \n  withSpring, \n  withTiming,\n  runOnJS\n} from 'react-native-reanimated';\n\nconst { width, height } = Dimensions.get('window');\n\n// Card model component\nconst CardModel = ({ \n  cardImage, \n  backImage, \n  isFlipped, \n  rotateX, \n  rotateY, \n  onFlipComplete \n}) => {\n  const meshRef = useRef();\n  const targetRotationY = useSharedValue(isFlipped ? Math.PI : 0);\n  const currentRotationY = useSharedValue(isFlipped ? Math.PI : 0);\n  const [flipping, setFlipping] = useState(false);\n  \n  // Load textures\n  const frontTexture = useLoader(TextureLoader, cardImage);\n  const backTexture = useLoader(TextureLoader, backImage);\n  \n  // Handle flip animation\n  useEffect(() => {\n    if (isFlipped !== (currentRotationY.value > Math.PI / 2)) {\n      setFlipping(true);\n      targetRotationY.value = isFlipped ? Math.PI : 0;\n    }\n  }, [isFlipped]);\n  \n  // Animation frame update\n  useFrame((state, delta) => {\n    if (meshRef.current) {\n      // Apply rotation from gesture\n      meshRef.current.rotation.x = rotateX.value;\n      \n      // Handle flip animation\n      if (flipping) {\n        const step = delta * 3; // Adjust speed as needed\n        const target = targetRotationY.value;\n        const current = currentRotationY.value;\n        \n        if (Math.abs(current - target) < 0.01) {\n          currentRotationY.value = target;\n          setFlipping(false);\n          if (onFlipComplete) {\n            onFlipComplete();\n          }\n        } else {\n          currentRotationY.value += (target - current) * step;\n        }\n      }\n      \n      // Apply Y rotation (combination of gesture and flip)\n      meshRef.current.rotation.y = rotateY.value + currentRotationY.value;\n      \n      // Add subtle floating animation\n      meshRef.current.position.y = Math.sin(state.clock.elapsedTime) * 0.05;\n    }\n  });\n  \n  return (\n    <mesh ref={meshRef} scale={[1.5, 2.25, 0.05]}>\n      <boxGeometry args={[1, 1, 0.05]} />\n      <meshStandardMaterial map={frontTexture} attachArray=\"material\" />\n      <meshStandardMaterial map={frontTexture} attachArray=\"material\" />\n      <meshStandardMaterial map={backTexture} attachArray=\"material\" />\n      <meshStandardMaterial map={backTexture} attachArray=\"material\" />\n      <meshStandardMaterial map={frontTexture} attachArray=\"material\" />\n      <meshStandardMaterial map={backTexture} attachArray=\"material\" />\n    </mesh>\n  );\n};\n\n// Main 3D Tarot Card component\nconst TarotCard3D = ({ \n  card, \n  onFlip, \n  initiallyFlipped = false,\n  style \n}) => {\n  const [isFlipped, setIsFlipped] = useState(initiallyFlipped);\n  const rotateX = useSharedValue(0);\n  const rotateY = useSharedValue(0);\n  \n  // Front and back image paths\n  const cardImagePath = card?.image \n    ? require('../assets/images/tarot/m00.jpg') // This would be dynamic in a real app\n    : require('../assets/images/tarot/back.jpg');\n  const backImagePath = require('../assets/images/tarot/back.jpg');\n  \n  // Handle pan gesture for rotation\n  const panGestureHandler = useAnimatedGestureHandler({\n    onStart: (_, ctx) => {\n      ctx.startX = rotateY.value;\n      ctx.startY = rotateX.value;\n    },\n    onActive: (event, ctx) => {\n      rotateY.value = ctx.startX + event.translationX / 100;\n      rotateX.value = ctx.startY - event.translationY / 100;\n    },\n    onEnd: () => {\n      rotateY.value = withSpring(0);\n      rotateX.value = withSpring(0);\n    },\n  });\n  \n  // Handle tap for flipping\n  const handleTap = () => {\n    setIsFlipped(!isFlipped);\n    if (onFlip) {\n      onFlip(!isFlipped);\n    }\n  };\n  \n  // Handle flip completion\n  const handleFlipComplete = () => {\n    // Additional actions after flip animation completes\n  };\n  \n  return (\n    <View style={[styles.container, style]}>\n      <PanGestureHandler onGestureEvent={panGestureHandler}>\n        <Animated.View style={styles.canvas}>\n          <Canvas style={styles.canvas} onTouchEnd={handleTap}>\n            <ambientLight intensity={0.6} />\n            <pointLight position={[10, 10, 10]} intensity={0.8} />\n            <CardModel \n              cardImage={cardImagePath}\n              backImage={backImagePath}\n              isFlipped={isFlipped}\n              rotateX={rotateX}\n              rotateY={rotateY}\n              onFlipComplete={handleFlipComplete}\n            />\n          </Canvas>\n        </Animated.View>\n      </PanGestureHandler>\n    </View>\n  );\n};\n\nconst styles = StyleSheet.create({\n  container: {\n    width: width * 0.8,\n    height: width * 1.2,\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  canvas: {\n    width: '100%',\n    height: '100%',\n    borderRadius: 10,\n    overflow: 'hidden',\n  },\n});\n\nexport default TarotCard3D;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}